ex8
formatter %{}
Should I use %{} or #{} for formatting?
You will almost always use #{} to format your strings, but there are times when you want to apply the same format to multiple values. That's when %{} comes in handy.

Ruby Refresher
********************************************************************************************************************************************
puts ""
Print to the console

#
Singleline Comment

=begin
=end
Multiline comment

cars = 100
puts cars
puts "There are #{cars} cars available."
Printing out variables

print vs puts
puts adds a newline to the end of the output. print does not.

my_test = 90
puts "This is a test variable with double quotes : #{my_test}"
puts 'This is a test variable with single quotes: #{my_test}'
=begin
This is a test variable with double quotes : 90
This is a test variable with single quotes: #{my_test}
=end

puts """
There's something going on here.
With the three double-quotes.
We'll be able to type as much as we like.
Even 4 lines if we want, or 5, or 6.
"""
Print block of lines

print "How old are you? "
age = gets.chomp
Take input from user
chomp will remove \n which is at the end
http://ruby-doc.org/docs/Tutorial/part_02/user_input.html
User input is string.

print "Give me a number: "
number = gets.chomp.to_i
To convert user input to int

print "Give me a number: "
number = gets.chomp.to_f
To convert user input to float

first, second, third = ARGV
puts "Your first variable is: #{first}"
puts "Your second variable is: #{second}"
puts "Your third variable is: #{third}"
Command line arguments

user_name = ARGV.first # gets the first argument
likes = $stdin.gets.chomp

File operations
Method 1 -> Script arguments
filename = ARGV.first
txt = open(filename)
puts "Here's your file #{filename}:"
print txt.read

Method 2 -> From console
print "Type the filename again: "
file_again = $stdin.gets.chomp
txt_again = open(file_again)
print txt_again.read

Files tutorial
https://launchschool.com/books/ruby/read/files

File modes
http://www.tutorialspoint.com/ruby/ruby_input_output.htm

close -- Closes the file
read -- Reads the contents of the file. You can assign the result to a variable.
readline -- Reads just one line of a text file.
truncate -- Empties the file. Watch out if you care about the file.
write('stuff') -- Writes "stuff" to the file.

Function
def print_some(arg1, arg2)
  puts "arg1: #{arg1}, arg2: #{arg2}"
end
print_some("One","Two")

input_file = ARGV.first
def print_all(f)
  puts f.read
end
def rewind(f)
  f.seek(0)
end
rewind function will take the file pointer again to the start of the file as the prevous function leaves it at the end.

Functions returning something
def add(a, b)
  puts "ADDING #{a} + #{b}"
  return a + b
end

poem = <<END
\tThe lovely world
with logic so firmly planted
cannot discern \n the needs of love
nor comprehend passion from intuition
and requires an explanation
\n\t\twhere there is none.
END
Called "heredoc" or "here document". It is used to create a multi-line string, and you use it by starting with << and an all caps word, in this case END. Ruby then reads everything into a string until it sees another END. You can use any word, not just END, so if your string has the word "END" in it, you would use something different like <<BIGDOC and end with BIGDOC. The last thing is the string includes all the indentation.

def secret_formula(started)
  jelly_beans = started * 500
  jars = jelly_beans / 1000
  crates = jars / 100
  return jelly_beans, jars, crates
end
beans, jars, crates = secret_formula(start_point)
puts "We'd have %s beans, %d jars, and %d crates." % secret_formula(start_point)
C style of inserting variables into Ruby strings

Lists
Split the string which has ' '
stuff.split(' ')
Sorting the strings
words.sort
Access the first string
words.shift
Access the last string
words.pop

if statement
if people < cats
  puts "Too many cats! The world is doomed!"
end

if-elsif-else statement
if cars > people
  puts "We should take the cars."
elsif cars < people
  puts "We should not take the cars."
else
  puts "We can't decide."
end

Arrays
fruits = ['apples', 'oranges', 'pears', 'apricots']
change = [1, 'pennies', 2, 'dimes', 3, 'quarters']
elements = []

for loop -> Type 1
for number in fruits
  puts "This is count #{number}"
end

for loop -> Type 2
fruits.each do |fruit|
  puts "A fruit of type: #{fruit}"
end

for loop -> Type 3
change.each {|i| puts "I got #{i}" }

Range operator
elements = []
(0..5).each do |i|
  puts "adding #{i} to the list."
  # pushes the i variable on the *end* of the list
  elements.push(i)
end

Ruby range operator
(1..5)        #==> 1, 2, 3, 4, 5
(1...5)       #==> 1, 2, 3, 4
('a'..'d')    #==> 'a', 'b', 'c', 'd'

Array push vs << (They are the same)
irb(main):001:0> num = [1,2,3]
=> [1, 2, 3]
irb(main):002:0> num.push(4)
=> [1, 2, 3, 4]
irb(main):003:0> num << 5
=> [1, 2, 3, 4, 5]
irb(main):004:0>

While loop
while i < 6
  puts "At the top i is #{i}"
  numbers.push(i)
  i += 1
  puts "Numbers now: ", numbers
  puts "At the bottom i is #{i}"
end
